# -*- coding: utf-8 -*-
#
# Configuration file for the Sphinx documentation builder.
#
# This file does only contain a selection of the most common options. For a
# full list see the documentation:
# http://www.sphinx-doc.org/en/master/config

# -- Path setup --------------------------------------------------------------

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
import os
import sys
sys.path.insert(0, os.path.abspath('..'))

# -- Project information -----------------------------------------------------

project = 'honeybee energy'
copyright = '2019, Ladybug Tools'
author = 'Ladybug Tools'

# The full version, including alpha/beta/rc tags
release = ''

# for example take major/minor
version = ''

# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.doctest',
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.imgmath',
    'sphinx.ext.ifconfig',
    'sphinx.ext.viewcode',
    'sphinx.ext.githubpages',
    'sphinxcontrib.fulltoc',
    'sphinx.ext.napoleon',
    'sphinx_click.ext'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = None

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = []

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = None


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
import sphinx_bootstrap_theme

# html_theme = 'alabaster'
html_theme = 'bootstrap'
html_theme_path = sphinx_bootstrap_theme.get_html_theme_path()

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
html_theme_options = {
    # For black navbar, do "navbar navbar-inverse"
    'navbar_class': "navbar navbar-inverse",
    # Fix navigation bar to top of page?
    # Values: "true" (default) or "false"
    'navbar_fixed_top': "true",
    'navbar_pagenav': True,
    'source_link_position': "nav",
    'bootswatch_theme': "united",
    'bootstrap_version': "3",
}

# Bootstrap theme custom file paths (relative to this file)
# Layout.html path (already added above, include if different)
# templates_path = ['_templates']

# on_rtd is whether we are on readthedocs.org
# on_rtd = os.environ.get('READTHEDOCS', None) == 'True'

# if not on_rtd:  # only import and set the theme if we're building docs locally
#    import sphinx_rtd_theme
#    html_theme = 'sphinx_rtd_theme'
#    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# The default sidebars (for documents that don't match any pattern) are
# defined by theme itself.  Builtin themes are using these templates by
# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',
# 'searchbox.html']``.
#
html_sidebars = {
    '**': ['localtoc.html']
}


# -- Options for HTMLHelp output ---------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = 'hbenergydoc'


# -- Options for LaTeX output ------------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',

    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (master_doc, 'honeybee energy.tex', 'honeybee energy Documentation',
     'Ladybug Tools', 'manual'),
]


# -- Options for manual page output ------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, 'honeybee energy', 'honeybee energy Documentation',
     [author], 1)
]


# -- Options for Texinfo output ----------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (master_doc, 'honeybee energy', 'honeybee energy Documentation',
     author, 'honeybee energy', 'One line description of project.',
     'Miscellaneous'),
]


# -- Options for Epub output -------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = project

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#
# epub_identifier = ''

# A unique identification for the text.
#
# epub_uid = ''

# A list of files that should not be packed into the epub file.
epub_exclude_files = ['search.html']


# -- Extension configuration -------------------------------------------------

# -- Options for todo extension ----------------------------------------------

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = True

# -- Options for autodoc extension --------------------------------------------
autodoc_default_options = {
    'inherited-members': True,
}

autodoc_member_order = 'groupwise'

# -- CLI documentation  -------------------------------------------------------
"""Improves the CLI documentation section.

In order to have separate html pages for each module inside library\\cli
additional documentation files(.rst) need to be generated in docs\\cli folder.

Note:
    This process assumes that each cli module represent a group of subcommands.
"""

# Library-command hash table. Created to address sub-command group names that
# differ from their library name. Format: {library_name : command_name}
ht_lib_command = {}

# Repository-library hash table. Creared to address library names that
#  differ from their repository name (beyond the dash-lower dash difference).
# Format: {repo_name : library_name}
ht_repo_lib = {}


def create_CLI_files():
    """Generates the rst files with CLI directives for each module detected in
    the library's cli folder. Updates index.rst file to include a list of
    sub-command documenation pages.
    """

    # Get CLI data from library
    repo_path = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
    repo_name, lib_name, mod_names = get_CLI_data(repo_path)

    if not mod_names:
        return

    # Prepare docs folder and rst files to create
    doc_folder = os.path.join(os.path.dirname(__file__), 'cli')
    if not os.path.isdir(doc_folder):
        os.mkdir(doc_folder)

    # Excluding CLI groups if corresponding rst file detected in docs/cli
    rst_names = [name for name in mod_names
                 if name + ".rst" not in os.listdir(doc_folder)]

    if not rst_names:
        return

    # Check in hash table for custom command line prog.name
    command_name = repo_name

    # Create rst files for each module(command group)
    result = write_rst_files(command_name, lib_name, rst_names, doc_folder)
    if not result:
        print ("Something went wrong during CLI docs generation")

    # Update/Create index file with command group section included
    result = update_index_data(os.path.join(doc_folder, 'index.rst'), rst_names)
    if not result:
        print ("Something went wrong during CLI index update")

    return


def get_CLI_data(repo_path):
    """Given a repository path, retrieves the repository and library names along
    with the names of modules found inside the cli folder.
    """
    repo_name = os.path.split(repo_path)[1]
    lib_name = repo_name.replace("-", "_")
    lib_path = os.path.abspath(os.path.join(repo_path, lib_name))

    if not os.path.isdir(lib_path):
        print ("Cannot find library path")
        return None

    CLI_path = os.path.join(lib_path, 'cli')
    if not os.path.isdir(lib_path):
        print ("No CLI library found")
        return None

    # Generate a list with the modules source files(.py).
    mod_names = [os.path.splitext(file)[0] for file in os.listdir(CLI_path)
                 if os.path.splitext(file)[1] == ".py"]

    # Extract files that aren't a cli module
    if "__init__" in mod_names:
        mod_names.remove("__init__")

    # Return library data
    return repo_name, lib_name, mod_names


def write_rst_files(comm_name, lib_name, rst_names, doc_folder):
    """Write a rst file with CLI directives for each rst file name.

    Args:
        comm_name: Command name used in the documentation.
        lib_name: CLI command library name.
        rst_names: The rst file names, also used for the command name.
        doc_folder: The path where cli docs will be saved.
    """

    # Creating missing CLI rst files
    print ("[CLI]: Creating ({}) CLI rst files: {}...".format(
        len(rst_names), rst_names))

    # Write CLI directive and options for each command-line group
    for group in rst_names:
        L = ["{}\n".format(group),
             "{}\n".format("=" * len(group)),
             "\n",
             ".. click:: {0}.cli.{1}:{1}\n".format(lib_name, group),
             "   :prog: {} {}\n".format(comm_name, group),
             "   :show-nested:\n"
             ]

        # Create CLI group file
        with open(os.path.join(doc_folder, group + ".rst"), 'w') as group_file:
            group_file.writelines(L)

    return True


def update_index_data(index_path, group_names):
    """ Updates the index.rst file inside the docs\\cli folder to include
    links to the newly created sub-command groups. If no index.rst file found,
    creates a new index.rst file.

    Args:
        index_path: index.rst file path to be updated or created from scratch.
        group_names: Name of the CLI sub-command groups to include in the
            'Commands' section.
    """

    print ("[CLI]: Updating index.rst file...")

    # Include exisitng index.rst data if present
    cli_content = []
    if os.path.isfile(index_path):
        with open(index_path, 'r') as index_file:
            lines = index_file.readlines()
        cli_content = lines[:lines.index("Commands\n")
                            ] if "Commands\n" in lines else lines
    else:
        # Otherwise create a "CLI" heading
        cli_content = ["CLI\n", "===\n", "\n"]

    # Add 'Commands' section with directive and options
    cli_content += ["\n"
                    "Commands\n",
                    "--------\n",
                    ".. toctree::\n",
                    "   :maxdepth: 1\n",
                    "\n"
                    ]

    # Add sub-command groups to content
    for group in group_names:
        cli_content.append("   {}\n".format(group))

    # Append section to file
    with open(index_path, 'w') as index_file:
        index_file.writelines(cli_content)

    return True


# Custom CLI docs function call.
# Commment the call below to exclude custom CLI docs from the doc. process.
create_CLI_files()


def setup(app):
    """Run custom code with access to the Sphinx application object
    Args:
        app: the Sphinx application object
    """

    # Add bootstrap theme custom stylesheet
    app.add_stylesheet("custom.css")
